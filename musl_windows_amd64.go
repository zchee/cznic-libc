// Code generated by 'ccgo -D__attribute__(x)= -ccgo-export-externs X -ccgo-hide __syscall0,__syscall1,__syscall2,__syscall3,__syscall4,__syscall5,__syscall6 -ccgo-libc -ccgo-long-double-is-double -ccgo-pkgname libc -nostdinc -o ../musl_windows_amd64.go -Iarch/x86_64 -Iarch/generic -Iobj/src/internal -Isrc/include -Isrc/internal -Iobj/include -Iinclude copyright.c src/ctype/isalnum.c src/ctype/isalpha.c src/ctype/isdigit.c src/ctype/islower.c src/ctype/isprint.c src/ctype/isspace.c src/ctype/isxdigit.c src/internal/intscan.c src/internal/shgetc.c src/stdio/__toread.c src/stdio/__uflow.c src/stdlib/strtol.c', DO NOT EDIT.

package libc

import (
	"math"
	"reflect"
	"unsafe"
)

var _ = math.Pi
var _ reflect.Kind
var _ unsafe.Pointer

// musl as a whole is licensed under the following standard MIT license:
//
// ----------------------------------------------------------------------
// Copyright © 2005-2020 Rich Felker, et al.
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
// IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
// CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
// TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
// SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
// ----------------------------------------------------------------------
//
// Authors/contributors include:
//
// A. Wilcox
// Ada Worcester
// Alex Dowad
// Alex Suykov
// Alexander Monakov
// Andre McCurdy
// Andrew Kelley
// Anthony G. Basile
// Aric Belsito
// Arvid Picciani
// Bartosz Brachaczek
// Benjamin Peterson
// Bobby Bingham
// Boris Brezillon
// Brent Cook
// Chris Spiegel
// Clément Vasseur
// Daniel Micay
// Daniel Sabogal
// Daurnimator
// David Carlier
// David Edelsohn
// Denys Vlasenko
// Dmitry Ivanov
// Dmitry V. Levin
// Drew DeVault
// Emil Renner Berthing
// Fangrui Song
// Felix Fietkau
// Felix Janda
// Gianluca Anzolin
// Hauke Mehrtens
// He X
// Hiltjo Posthuma
// Isaac Dunham
// Jaydeep Patil
// Jens Gustedt
// Jeremy Huntwork
// Jo-Philipp Wich
// Joakim Sindholt
// John Spencer
// Julien Ramseier
// Justin Cormack
// Kaarle Ritvanen
// Khem Raj
// Kylie McClain
// Leah Neukirchen
// Luca Barbato
// Luka Perkov
// M Farkas-Dyck (Strake)
// Mahesh Bodapati
// Markus Wichmann
// Masanori Ogino
// Michael Clark
// Michael Forney
// Mikhail Kremnyov
// Natanael Copa
// Nicholas J. Kain
// orc
// Pascal Cuoq
// Patrick Oppenlander
// Petr Hosek
// Petr Skocik
// Pierre Carrier
// Reini Urban
// Rich Felker
// Richard Pennington
// Ryan Fairfax
// Samuel Holland
// Segev Finer
// Shiz
// sin
// Solar Designer
// Stefan Kristiansson
// Stefan O'Rear
// Szabolcs Nagy
// Timo Teräs
// Trutz Behn
// Valentin Ochs
// Will Dietz
// William Haddon
// William Pitcock
//
// Portions of this software are derived from third-party works licensed
// under terms compatible with the above MIT license:
//
// The TRE regular expression implementation (src/regex/reg* and
// src/regex/tre*) is Copyright © 2001-2008 Ville Laurikari and licensed
// under a 2-clause BSD license (license text in the source files). The
// included version has been heavily modified by Rich Felker in 2012, in
// the interests of size, simplicity, and namespace cleanliness.
//
// Much of the math library code (src/math/* and src/complex/*) is
// Copyright © 1993,2004 Sun Microsystems or
// Copyright © 2003-2011 David Schultz or
// Copyright © 2003-2009 Steven G. Kargl or
// Copyright © 2003-2009 Bruce D. Evans or
// Copyright © 2008 Stephen L. Moshier or
// Copyright © 2017-2018 Arm Limited
// and labelled as such in comments in the individual source files. All
// have been licensed under extremely permissive terms.
//
// The ARM memcpy code (src/string/arm/memcpy.S) is Copyright © 2008
// The Android Open Source Project and is licensed under a two-clause BSD
// license. It was taken from Bionic libc, used on Android.
//
// The AArch64 memcpy and memset code (src/string/aarch64/*) are
// Copyright © 1999-2019, Arm Limited.
//
// The implementation of DES for crypt (src/crypt/crypt_des.c) is
// Copyright © 1994 David Burren. It is licensed under a BSD license.
//
// The implementation of blowfish crypt (src/crypt/crypt_blowfish.c) was
// originally written by Solar Designer and placed into the public
// domain. The code also comes with a fallback permissive license for use
// in jurisdictions that may not recognize the public domain.
//
// The smoothsort implementation (src/stdlib/qsort.c) is Copyright © 2011
// Valentin Ochs and is licensed under an MIT-style license.
//
// The x86_64 port was written by Nicholas J. Kain and is licensed under
// the standard MIT terms.
//
// The mips and microblaze ports were originally written by Richard
// Pennington for use in the ellcc project. The original code was adapted
// by Rich Felker for build system and code conventions during upstream
// integration. It is licensed under the standard MIT terms.
//
// The mips64 port was contributed by Imagination Technologies and is
// licensed under the standard MIT terms.
//
// The powerpc port was also originally written by Richard Pennington,
// and later supplemented and integrated by John Spencer. It is licensed
// under the standard MIT terms.
//
// All other files which have no copyright comments are original works
// produced specifically for use as part of this library, written either
// by Rich Felker, the main author of the library, or by one or more
// contibutors listed above. Details on authorship of individual files
// can be found in the git version control history of the project. The
// omission of copyright and license comments in each file is in the
// interest of source tree size.
//
// In addition, permission is hereby granted for all public header files
// (include/* and arch/*/bits/*) and crt files intended to be linked into
// applications (crt/*, ldso/dlstart.c, and arch/*/crt_arch.h) to omit
// the copyright notice and permission notice otherwise required by the
// license, and to use these files without any requirement of
// attribution. These files include substantial contributions from:
//
// Bobby Bingham
// John Spencer
// Nicholas J. Kain
// Rich Felker
// Richard Pennington
// Stefan Kristiansson
// Szabolcs Nagy
//
// all of whom have explicitly granted such permission.
//
// This file previously contained text expressing a belief that most of
// the files covered by the above exception were sufficiently trivial not
// to be subject to copyright, resulting in confusion over whether it
// negated the permissions granted in the license. In the spirit of
// permissive licensing, and of not having licensing issues being an
// obstacle to adoption, that text has been removed.
const ( /* copyright.c:194:1: */
	__musl__copyright__ = 0
)

type ptrdiff_t = int64 /* <builtin>:3:26 */

type size_t = uint64 /* <builtin>:9:23 */

type wchar_t = uint16 /* <builtin>:15:24 */

type va_list = uintptr /* <builtin>:38:27 */

func __isspace(tls *TLS, _c int32) int32 { /* ctype.h:26:21: */
	return (Bool32((_c == ' ') || ((uint32(_c) - uint32('\t')) < uint32(5))))
}

type locale_t = uintptr /* alltypes.h:343:32 */

func Xisalnum(tls *TLS, c int32) int32 { /* isalnum.c:3:5: */
	return (Bool32((func() int32 {
		if 0 != 0 {
			return Xisalpha(tls, c)
		}
		return (Bool32((((uint32(c)) | uint32(32)) - uint32('a')) < uint32(26)))
	}() != 0) || (func() int32 {
		if 0 != 0 {
			return Xisdigit(tls, c)
		}
		return (Bool32(((uint32(c)) - uint32('0')) < uint32(10)))
	}() != 0)))
}

func X__isalnum_l(tls *TLS, c int32, l locale_t) int32 { /* isalnum.c:8:5: */
	return Xisalnum(tls, c)
}

func Xisalpha(tls *TLS, c int32) int32 { /* isalpha.c:4:5: */
	return (Bool32(((uint32(c) | uint32(32)) - uint32('a')) < uint32(26)))
}

func X__isalpha_l(tls *TLS, c int32, l locale_t) int32 { /* isalpha.c:9:5: */
	return Xisalpha(tls, c)
}

func Xisdigit(tls *TLS, c int32) int32 { /* isdigit.c:4:5: */
	return (Bool32((uint32(c) - uint32('0')) < uint32(10)))
}

func X__isdigit_l(tls *TLS, c int32, l locale_t) int32 { /* isdigit.c:9:5: */
	return Xisdigit(tls, c)
}

func Xislower(tls *TLS, c int32) int32 { /* islower.c:4:5: */
	return (Bool32((uint32(c) - uint32('a')) < uint32(26)))
}

func X__islower_l(tls *TLS, c int32, l locale_t) int32 { /* islower.c:9:5: */
	return Xislower(tls, c)
}

func Xisprint(tls *TLS, c int32) int32 { /* isprint.c:4:5: */
	return (Bool32((uint32(c) - uint32(0x20)) < uint32(0x5f)))
}

func X__isprint_l(tls *TLS, c int32, l locale_t) int32 { /* isprint.c:9:5: */
	return Xisprint(tls, c)
}

func Xisspace(tls *TLS, c int32) int32 { /* isspace.c:4:5: */
	return (Bool32((c == ' ') || ((uint32(c) - uint32('\t')) < uint32(5))))
}

func X__isspace_l(tls *TLS, c int32, l locale_t) int32 { /* isspace.c:9:5: */
	return Xisspace(tls, c)
}

func Xisxdigit(tls *TLS, c int32) int32 { /* isxdigit.c:3:5: */
	return (Bool32((func() int32 {
		if 0 != 0 {
			return Xisdigit(tls, c)
		}
		return (Bool32(((uint32(c)) - uint32('0')) < uint32(10)))
	}() != 0) || (((uint32(c) | uint32(32)) - uint32('a')) < uint32(6))))
}

func X__isxdigit_l(tls *TLS, c int32, l locale_t) int32 { /* isxdigit.c:8:5: */
	return Xisxdigit(tls, c)
}

type ssize_t = int32 /* alltypes.h:65:15 */

type off_t = int32 /* alltypes.h:162:16 */

type _IO_FILE = struct {
	flags        uint32
	_            [4]byte
	rpos         uintptr
	rend         uintptr
	close        uintptr
	wend         uintptr
	wpos         uintptr
	mustbezero_1 uintptr
	wbase        uintptr
	read         uintptr
	write        uintptr
	seek         uintptr
	buf          uintptr
	buf_size     size_t
	prev         uintptr
	next         uintptr
	fd           int32
	pipe_pid     int32
	lockcount    int32
	mode         int32
	lock         int32
	lbf          int32
	cookie       uintptr
	off          off_t
	_            [4]byte
	getln_buf    uintptr
	mustbezero_2 uintptr
	shend        uintptr
	shlim        off_t
	shcnt        off_t
	prev_locked  uintptr
	next_locked  uintptr
	locale       uintptr
} /* alltypes.h:320:9 */

type FILE = _IO_FILE /* alltypes.h:320:25 */

type _G_fpos64_t = struct {
	_        [0]uint64
	__opaque [16]int8
} /* stdio.h:54:9 */

type fpos_t = _G_fpos64_t /* stdio.h:58:3 */

type syscall_arg_t = int32 /* syscall.h:22:14 */

// Lookup table for digit values. -1==255>=36 -> invalid
var table = [257]uint8{Uint8FromInt32(-1),
	Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1),
	Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1),
	Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1),
	uint8(0), uint8(1), uint8(2), uint8(3), uint8(4), uint8(5), uint8(6), uint8(7), uint8(8), uint8(9), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1),
	Uint8FromInt32(-1), uint8(10), uint8(11), uint8(12), uint8(13), uint8(14), uint8(15), uint8(16), uint8(17), uint8(18), uint8(19), uint8(20), uint8(21), uint8(22), uint8(23), uint8(24),
	uint8(25), uint8(26), uint8(27), uint8(28), uint8(29), uint8(30), uint8(31), uint8(32), uint8(33), uint8(34), uint8(35), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1),
	Uint8FromInt32(-1), uint8(10), uint8(11), uint8(12), uint8(13), uint8(14), uint8(15), uint8(16), uint8(17), uint8(18), uint8(19), uint8(20), uint8(21), uint8(22), uint8(23), uint8(24),
	uint8(25), uint8(26), uint8(27), uint8(28), uint8(29), uint8(30), uint8(31), uint8(32), uint8(33), uint8(34), uint8(35), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1),
	Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1),
	Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1),
	Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1),
	Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1),
	Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1),
	Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1),
	Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1),
	Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1),
} /* intscan.c:7:28 */

func X__intscan(tls *TLS, f uintptr, base uint32, pok int32, lim uint64) uint64 { /* intscan.c:26:20: */
	var val uintptr
	var c int32
	var neg int32
	var x uint32
	var y uint64
	var bs int32
	val = (uintptr(unsafe.Pointer(&table)) + uintptr(1))
	neg = 0
	if !((base > uint32(36)) || (base == uint32(1))) {
		goto __1
	}
	(*(*int32)(unsafe.Pointer(X___errno_location(tls)))) = 22
	return uint64(0)
__1:
	;
__2:
	if !(__isspace(tls, AssignInt32(&c, func() int32 {
		if (*FILE)(unsafe.Pointer((f))).rpos != (*FILE)(unsafe.Pointer((f))).shend {
			return int32(*(*uint8)(unsafe.Pointer(PostIncUintptr(&(*FILE)(unsafe.Pointer(f)).rpos, 1))))
		}
		return X__shgetc(tls, f)
	}())) != 0) {
		goto __3
	}
	goto __2
__3:
	;
	if !((c == '+') || (c == '-')) {
		goto __4
	}
	neg = -(Bool32(c == '-'))
	c = func() int32 {
		if (*FILE)(unsafe.Pointer((f))).rpos != (*FILE)(unsafe.Pointer((f))).shend {
			return int32(*(*uint8)(unsafe.Pointer(PostIncUintptr(&(*FILE)(unsafe.Pointer(f)).rpos, 1))))
		}
		return X__shgetc(tls, f)
	}()
__4:
	;
	if !(((base == uint32(0)) || (base == uint32(16))) && (c == '0')) {
		goto __5
	}
	c = func() int32 {
		if (*FILE)(unsafe.Pointer((f))).rpos != (*FILE)(unsafe.Pointer((f))).shend {
			return int32(*(*uint8)(unsafe.Pointer(PostIncUintptr(&(*FILE)(unsafe.Pointer(f)).rpos, 1))))
		}
		return X__shgetc(tls, f)
	}()
	if !((c | 32) == 'x') {
		goto __7
	}
	c = func() int32 {
		if (*FILE)(unsafe.Pointer((f))).rpos != (*FILE)(unsafe.Pointer((f))).shend {
			return int32(*(*uint8)(unsafe.Pointer(PostIncUintptr(&(*FILE)(unsafe.Pointer(f)).rpos, 1))))
		}
		return X__shgetc(tls, f)
	}()
	if !(int32(*(*uint8)(unsafe.Pointer(val + uintptr(c)))) >= 16) {
		goto __9
	}
	if (*FILE)(unsafe.Pointer((f))).shlim >= 0 {
		(*FILE)(unsafe.Pointer(f)).rpos--
	} else {
	}
	if !(pok != 0) {
		goto __10
	}
	if (*FILE)(unsafe.Pointer((f))).shlim >= 0 {
		(*FILE)(unsafe.Pointer(f)).rpos--
	} else {
	}
	goto __11
__10:
	X__shlim(tls, f, 0)
__11:
	;
	return uint64(0)
__9:
	;
	base = uint32(16)
	goto __8
__7:
	if !(base == uint32(0)) {
		goto __12
	}
	base = uint32(8)
__12:
	;
__8:
	;
	goto __6
__5:
	if !(base == uint32(0)) {
		goto __13
	}
	base = uint32(10)
__13:
	;
	if !(uint32(*(*uint8)(unsafe.Pointer(val + uintptr(c)))) >= base) {
		goto __14
	}
	if (*FILE)(unsafe.Pointer((f))).shlim >= 0 {
		(*FILE)(unsafe.Pointer(f)).rpos--
	} else {
	}
	X__shlim(tls, f, 0)
	(*(*int32)(unsafe.Pointer(X___errno_location(tls)))) = 22
	return uint64(0)
__14:
	;
__6:
	;
	if !(base == uint32(10)) {
		goto __15
	}
	x = uint32(0)
__17:
	if !(((uint32(c - '0')) < 10) && (x <= ((0xffffffff / uint32(10)) - uint32(1)))) {
		goto __19
	}
	x = ((x * uint32(10)) + (uint32(c - '0')))
	goto __18
__18:
	c = func() int32 {
		if (*FILE)(unsafe.Pointer((f))).rpos != (*FILE)(unsafe.Pointer((f))).shend {
			return int32(*(*uint8)(unsafe.Pointer(PostIncUintptr(&(*FILE)(unsafe.Pointer(f)).rpos, 1))))
		}
		return X__shgetc(tls, f)
	}()
	goto __17
	goto __19
__19:
	;
	y = uint64(x)
__20:
	if !((((uint32(c - '0')) < 10) && (y <= (((2 * uint64(0x7fffffffffffffff)) + uint64(1)) / uint64(10)))) && ((uint64(10) * y) <= (((2 * uint64(0x7fffffffffffffff)) + uint64(1)) - (uint64(c - '0'))))) {
		goto __22
	}
	y = ((y * uint64(10)) + (uint64(c - '0')))
	goto __21
__21:
	c = func() int32 {
		if (*FILE)(unsafe.Pointer((f))).rpos != (*FILE)(unsafe.Pointer((f))).shend {
			return int32(*(*uint8)(unsafe.Pointer(PostIncUintptr(&(*FILE)(unsafe.Pointer(f)).rpos, 1))))
		}
		return X__shgetc(tls, f)
	}()
	goto __20
	goto __22
__22:
	;
	if !((uint32(c - '0')) >= 10) {
		goto __23
	}
	goto done
__23:
	;
	goto __16
__15:
	if !(!((base & (base - uint32(1))) != 0)) {
		goto __24
	}
	bs = int32(*(*int8)(unsafe.Pointer(ts /* "\x00\x01\x02\x04\a\x03\x06\x05" */ + uintptr((((uint32(0x17) * base) >> 5) & uint32(7))))))
	x = uint32(0)
__26:
	if !((uint32(*(*uint8)(unsafe.Pointer(val + uintptr(c)))) < base) && (x <= (0xffffffff / uint32(32)))) {
		goto __28
	}
	x = ((x << bs) | uint32(*(*uint8)(unsafe.Pointer(val + uintptr(c)))))
	goto __27
__27:
	c = func() int32 {
		if (*FILE)(unsafe.Pointer((f))).rpos != (*FILE)(unsafe.Pointer((f))).shend {
			return int32(*(*uint8)(unsafe.Pointer(PostIncUintptr(&(*FILE)(unsafe.Pointer(f)).rpos, 1))))
		}
		return X__shgetc(tls, f)
	}()
	goto __26
	goto __28
__28:
	;
	y = uint64(x)
__29:
	if !((uint32(*(*uint8)(unsafe.Pointer(val + uintptr(c)))) < base) && (y <= (uint64(((2 * uint64(0x7fffffffffffffff)) + uint64(1))) >> bs))) {
		goto __31
	}
	y = ((y << bs) | uint64(*(*uint8)(unsafe.Pointer(val + uintptr(c)))))
	goto __30
__30:
	c = func() int32 {
		if (*FILE)(unsafe.Pointer((f))).rpos != (*FILE)(unsafe.Pointer((f))).shend {
			return int32(*(*uint8)(unsafe.Pointer(PostIncUintptr(&(*FILE)(unsafe.Pointer(f)).rpos, 1))))
		}
		return X__shgetc(tls, f)
	}()
	goto __29
	goto __31
__31:
	;
	goto __25
__24:
	x = uint32(0)
__32:
	if !((uint32(*(*uint8)(unsafe.Pointer(val + uintptr(c)))) < base) && (x <= ((0xffffffff / uint32(36)) - uint32(1)))) {
		goto __34
	}
	x = ((x * base) + uint32(*(*uint8)(unsafe.Pointer(val + uintptr(c)))))
	goto __33
__33:
	c = func() int32 {
		if (*FILE)(unsafe.Pointer((f))).rpos != (*FILE)(unsafe.Pointer((f))).shend {
			return int32(*(*uint8)(unsafe.Pointer(PostIncUintptr(&(*FILE)(unsafe.Pointer(f)).rpos, 1))))
		}
		return X__shgetc(tls, f)
	}()
	goto __32
	goto __34
__34:
	;
	y = uint64(x)
__35:
	if !(((uint32(*(*uint8)(unsafe.Pointer(val + uintptr(c)))) < base) && (y <= (((2 * uint64(0x7fffffffffffffff)) + uint64(1)) / uint64(base)))) && ((uint64(base) * y) <= (((2 * uint64(0x7fffffffffffffff)) + uint64(1)) - uint64(*(*uint8)(unsafe.Pointer(val + uintptr(c))))))) {
		goto __37
	}
	y = ((y * uint64(base)) + uint64(*(*uint8)(unsafe.Pointer(val + uintptr(c)))))
	goto __36
__36:
	c = func() int32 {
		if (*FILE)(unsafe.Pointer((f))).rpos != (*FILE)(unsafe.Pointer((f))).shend {
			return int32(*(*uint8)(unsafe.Pointer(PostIncUintptr(&(*FILE)(unsafe.Pointer(f)).rpos, 1))))
		}
		return X__shgetc(tls, f)
	}()
	goto __35
	goto __37
__37:
	;
__25:
	;
__16:
	;
	if !(uint32(*(*uint8)(unsafe.Pointer(val + uintptr(c)))) < base) {
		goto __38
	}
__39:
	if !(uint32(*(*uint8)(unsafe.Pointer(val + uintptr(c)))) < base) {
		goto __41
	}
	goto __40
__40:
	c = func() int32 {
		if (*FILE)(unsafe.Pointer((f))).rpos != (*FILE)(unsafe.Pointer((f))).shend {
			return int32(*(*uint8)(unsafe.Pointer(PostIncUintptr(&(*FILE)(unsafe.Pointer(f)).rpos, 1))))
		}
		return X__shgetc(tls, f)
	}()
	goto __39
	goto __41
__41:
	;
	(*(*int32)(unsafe.Pointer(X___errno_location(tls)))) = 34
	y = lim
	if !((lim & uint64(1)) != 0) {
		goto __42
	}
	neg = 0
__42:
	;
__38:
	;
done:
	if (*FILE)(unsafe.Pointer((f))).shlim >= 0 {
		(*FILE)(unsafe.Pointer(f)).rpos--
	} else {
	}
	if !(y >= lim) {
		goto __43
	}
	if !(!((lim & uint64(1)) != 0) && !(neg != 0)) {
		goto __44
	}
	(*(*int32)(unsafe.Pointer(X___errno_location(tls)))) = 34
	return (lim - uint64(1))
	goto __45
__44:
	if !(y > lim) {
		goto __46
	}
	(*(*int32)(unsafe.Pointer(X___errno_location(tls)))) = 34
	return lim
__46:
	;
__45:
	;
__43:
	;
	return ((y ^ uint64(neg)) - uint64(neg))
}

// The shcnt field stores the number of bytes read so far, offset by
// the value of buf-rpos at the last function call (__shlim or __shgetc),
// so that between calls the inline shcnt macro can add rpos-buf to get
// the actual count.

func X__shlim(tls *TLS, f uintptr, lim off_t) { /* shgetc.c:8:6: */
	(*FILE)(unsafe.Pointer(f)).shlim = lim
	(*FILE)(unsafe.Pointer(f)).shcnt = (off_t((int64((*FILE)(unsafe.Pointer(f)).buf) - int64((*FILE)(unsafe.Pointer(f)).rpos)) / 1))
	// If lim is nonzero, rend must be a valid pointer.
	if (lim != 0) && (((int64((*FILE)(unsafe.Pointer(f)).rend) - int64((*FILE)(unsafe.Pointer(f)).rpos)) / 1) > int64(lim)) {
		(*FILE)(unsafe.Pointer(f)).shend = ((*FILE)(unsafe.Pointer(f)).rpos + uintptr(lim))
	} else {
		(*FILE)(unsafe.Pointer(f)).shend = (*FILE)(unsafe.Pointer(f)).rend
	}
}

func X__shgetc(tls *TLS, f uintptr) int32 { /* shgetc.c:19:5: */
	var c int32
	var cnt off_t = (off_t(int64((*FILE)(unsafe.Pointer((f))).shcnt) + ((int64((*FILE)(unsafe.Pointer((f))).rpos) - int64((*FILE)(unsafe.Pointer((f))).buf)) / 1)))
	if (((*FILE)(unsafe.Pointer(f)).shlim != 0) && (cnt >= (*FILE)(unsafe.Pointer(f)).shlim)) || ((AssignInt32(&c, X__uflow(tls, f))) < 0) {
		(*FILE)(unsafe.Pointer(f)).shcnt = (off_t(((int64((*FILE)(unsafe.Pointer(f)).buf) - int64((*FILE)(unsafe.Pointer(f)).rpos)) / 1) + int64(cnt)))
		(*FILE)(unsafe.Pointer(f)).shend = (*FILE)(unsafe.Pointer(f)).rpos
		(*FILE)(unsafe.Pointer(f)).shlim = -1
		return -1
	}
	cnt++
	if ((*FILE)(unsafe.Pointer(f)).shlim != 0) && (((int64((*FILE)(unsafe.Pointer(f)).rend) - int64((*FILE)(unsafe.Pointer(f)).rpos)) / 1) > (int64((*FILE)(unsafe.Pointer(f)).shlim - cnt))) {
		(*FILE)(unsafe.Pointer(f)).shend = ((*FILE)(unsafe.Pointer(f)).rpos + uintptr(((*FILE)(unsafe.Pointer(f)).shlim - cnt)))
	} else {
		(*FILE)(unsafe.Pointer(f)).shend = (*FILE)(unsafe.Pointer(f)).rend
	}
	(*FILE)(unsafe.Pointer(f)).shcnt = (off_t(((int64((*FILE)(unsafe.Pointer(f)).buf) - int64((*FILE)(unsafe.Pointer(f)).rpos)) / 1) + int64(cnt)))
	if (*FILE)(unsafe.Pointer(f)).rpos <= (*FILE)(unsafe.Pointer(f)).buf {
		*(*uint8)(unsafe.Pointer((*FILE)(unsafe.Pointer(f)).rpos + UintptrFromInt32(-1))) = uint8(c)
	}
	return c
}

func X__toread(tls *TLS, f uintptr) int32 { /* __toread.c:3:5: */
	*(*int32)(unsafe.Pointer(f + 132 /* &.mode */)) |= ((*FILE)(unsafe.Pointer(f)).mode - 1)
	if (*FILE)(unsafe.Pointer(f)).wpos != (*FILE)(unsafe.Pointer(f)).wbase {
		(*(*func(*TLS, uintptr, uintptr, size_t) size_t)(unsafe.Pointer((f + 72 /* &.write */))))(tls, f, uintptr(0), uint64(0))
	}
	(*FILE)(unsafe.Pointer(f)).wpos = AssignPtrUintptr(f+56 /* &.wbase */, AssignPtrUintptr(f+32 /* &.wend */, uintptr(0)))
	if ((*FILE)(unsafe.Pointer(f)).flags & uint32(4)) != 0 {
		*(*uint32)(unsafe.Pointer(f /* &.flags */)) |= (uint32(32))
		return -1
	}
	(*FILE)(unsafe.Pointer(f)).rpos = AssignPtrUintptr(f+16 /* &.rend */, ((*FILE)(unsafe.Pointer(f)).buf + uintptr((*FILE)(unsafe.Pointer(f)).buf_size)))
	if ((*FILE)(unsafe.Pointer(f)).flags & uint32(16)) != 0 {
		return -1
	}
	return 0
}

func X__toread_needs_stdio_exit(tls *TLS) { /* __toread.c:16:13: */
	X__builtin_abort(tls) //TODO-
	// __stdio_exit_needed();
}

// This function assumes it will never be called if there is already
// data buffered for reading.

func X__uflow(tls *TLS, f uintptr) int32 { /* __uflow.c:6:5: */
	bp := tls.Alloc(1)
	defer tls.Free(1)

	// var c uint8 at bp, 1

	if !(X__toread(tls, f) != 0) && ((*(*func(*TLS, uintptr, uintptr, size_t) size_t)(unsafe.Pointer((f + 64 /* &.read */))))(tls, f, bp /* &c */, uint64(1)) == uint64(1)) {
		return int32(*(*uint8)(unsafe.Pointer(bp /* c */)))
	}
	return -1
}

type uintptr_t = uint32 /* alltypes.h:55:24 */

type intptr_t = int32 /* alltypes.h:70:15 */

type int8_t = int8 /* alltypes.h:96:25 */

type int16_t = int16 /* alltypes.h:101:25 */

type int32_t = int32 /* alltypes.h:106:25 */

type int64_t = int32 /* alltypes.h:111:25 */

type intmax_t = int32 /* alltypes.h:116:25 */

type uint8_t = uint8 /* alltypes.h:121:25 */

type uint16_t = uint16 /* alltypes.h:126:25 */

type uint32_t = uint32 /* alltypes.h:131:25 */

type uint64_t = uint32 /* alltypes.h:136:25 */

type uintmax_t = uint32 /* alltypes.h:146:25 */

type int_fast8_t = int8_t   /* stdint.h:22:16 */
type int_fast64_t = int64_t /* stdint.h:23:17 */

type int_least8_t = int8_t   /* stdint.h:25:17 */
type int_least16_t = int16_t /* stdint.h:26:17 */
type int_least32_t = int32_t /* stdint.h:27:17 */
type int_least64_t = int64_t /* stdint.h:28:17 */

type uint_fast8_t = uint8_t   /* stdint.h:30:17 */
type uint_fast64_t = uint64_t /* stdint.h:31:18 */

type uint_least8_t = uint8_t   /* stdint.h:33:18 */
type uint_least16_t = uint16_t /* stdint.h:34:18 */
type uint_least32_t = uint32_t /* stdint.h:35:18 */
type uint_least64_t = uint64_t /* stdint.h:36:18 */

type int_fast16_t = int32_t   /* stdint.h:1:17 */
type int_fast32_t = int32_t   /* stdint.h:2:17 */
type uint_fast16_t = uint32_t /* stdint.h:3:18 */
type uint_fast32_t = uint32_t /* stdint.h:4:18 */

type imaxdiv_t = struct {
	quot intmax_t
	rem  intmax_t
} /* inttypes.h:14:40 */

func strtox(tls *TLS, s uintptr, p uintptr, base int32, lim uint64) uint64 { /* strtol.c:8:27: */
	bp := tls.Alloc(216)
	defer tls.Free(216)

	// var f FILE at bp, 216

	(*FILE)(unsafe.Pointer(bp /* &f */)).buf = AssignPtrUintptr(bp /* &f */ +8 /* &.rpos */, s)
	(*FILE)(unsafe.Pointer(bp /* &f */)).rend = UintptrFromInt32(-1)
	X__shlim(tls, bp /* &f */, 0)
	var y uint64 = X__intscan(tls, bp /* &f */, uint32(base), 1, lim)
	if p != 0 {
		var cnt size_t = (size_t(int64((*FILE)(unsafe.Pointer((bp /* &f */))).shcnt) + ((int64((*FILE)(unsafe.Pointer((bp /* &f */))).rpos) - int64((*FILE)(unsafe.Pointer((bp /* &f */))).buf)) / 1)))
		*(*uintptr)(unsafe.Pointer(p)) = (s + uintptr(cnt))
	}
	return y
}

func Xstrtoull(tls *TLS, s uintptr, p uintptr, base int32) uint64 { /* strtol.c:21:20: */
	return strtox(tls, s, p, base, ((2 * uint64(0x7fffffffffffffff)) + uint64(1)))
}

func Xstrtoll(tls *TLS, s uintptr, p uintptr, base int32) int64 { /* strtol.c:26:11: */
	return int64(strtox(tls, s, p, base, (Uint64FromInt64(-0x7fffffffffffffff - int64(1)))))
}

func Xstrtoul(tls *TLS, s uintptr, p uintptr, base int32) uint32 { /* strtol.c:31:15: */
	return uint32(strtox(tls, s, p, base, (Uint64FromInt64((Int64FromUint32(2) * Int64(0x7fffffffffffffff)) + int64(1)))))
}

func Xstrtol(tls *TLS, s uintptr, p uintptr, base int32) int32 { /* strtol.c:36:6: */
	return int32(strtox(tls, s, p, base, (Uint64FromInt64(int64(0) + (-0x7fffffffffffffff - int64(1))))))
}

func Xstrtoimax(tls *TLS, s uintptr, p uintptr, base int32) intmax_t { /* strtol.c:41:10: */
	return intmax_t(Xstrtoll(tls, s, p, base))
}

func Xstrtoumax(tls *TLS, s uintptr, p uintptr, base int32) uintmax_t { /* strtol.c:46:11: */
	return uintmax_t(Xstrtoull(tls, s, p, base))
}

var ts1 = "\x00\x01\x02\x04\a\x03\x06\x05\x00"
var ts = (*reflect.StringHeader)(unsafe.Pointer(&ts1)).Data
